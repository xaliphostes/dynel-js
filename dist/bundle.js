!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.dynel=e():t.dynel=e()}(this,()=>(()=>{"use strict";var t={d:(e,s)=>{for(var i in s)t.o(s,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:s[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{GaussSeidel:()=>s,Model:()=>i,restore:()=>o});class s{constructor(t=1e-6,e=1e4,s=.8){this.convergenceThreshold=1e-6,this.maxIterations=1e4,this.damping=.8,this.isRunning=!1,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0,this.convergenceThreshold=t,this.maxIterations=e,this.damping=s}get running(){return this.isRunning}get paused(){return this.isPaused}get iterations(){return this.currentIteration}get error(){return this.currentError}setConvergenceThreshold(t){this.convergenceThreshold=t}setMaxIterations(t){this.maxIterations=t}setDamping(t){this.damping=t}start(t){this.isRunning=!0,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0;for(const e of t.getNodes())e.displacement={x:0,y:0}}async step(t){if(!this.isRunning||this.isPaused)return null;const e=this.gaussSeidelIteration(t);this.currentIteration++,this.currentError=e;const s=e<=this.convergenceThreshold,i=this.currentIteration>=this.maxIterations;return(s||i)&&(this.isRunning=!1),{converged:s,iterations:this.currentIteration,error:e,running:this.isRunning,maxDisplacement:e}}pause(){this.isPaused=!this.isPaused}reset(t){this.isRunning=!1,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0;for(const e of t.getNodes())e.position.x=e.originalPosition.x,e.position.y=e.originalPosition.y,e.displacement={x:0,y:0},e.force={x:0,y:0}}async solve(t,e,s,i=1){if(this.isRunning)return;this.start(t);const o=16/i;for(;this.isRunning;){const i=await this.step(t);if(i){if(e(),s(i),i.converged){console.log(`Solver converged after ${i.iterations} iterations with error ${i.error.toExponential(3)}`);break}if(i.iterations>=this.maxIterations){console.log(`Solver stopped at max iterations (${i.iterations}) with error ${i.error.toExponential(3)}`);break}}await new Promise(t=>setTimeout(t,o))}this.isRunning=!1}gaussSeidelIteration(t){let e=0;for(const s of t.getNodes()){if(s.isFixed)continue;let i={x:s.force.x,y:s.force.y};for(const e of t.getTriangles())if(e.nodeIds.includes(s.id)){const o=t.computeNodalForces(e).get(s.id);o&&(i.x+=o.x,i.y+=o.y)}const o=t.computeNodalStiffness(s.id),n=o[0][0]*o[1][1]-o[0][1]*o[1][0];if(Math.abs(n)>1e-12){const t=[[o[1][1]/n,-o[0][1]/n],[-o[1][0]/n,o[0][0]/n]],r={x:t[0][0]*i.x+t[0][1]*i.y,y:t[1][0]*i.x+t[1][1]*i.y};s.fixedX||(s.position.x+=this.damping*r.x,s.displacement.x+=this.damping*r.x,e=Math.max(e,Math.abs(r.x))),s.fixedY||(s.position.y+=this.damping*r.y,s.displacement.y+=this.damping*r.y,e=Math.max(e,Math.abs(r.y)))}}return e}}class i{constructor(){this.nodes=new Map,this.triangles=new Map,this.contacts=[]}addNode(t,e,s,i=!1){this.nodes.set(t,{id:t,position:{x:e,y:s},originalPosition:{x:e,y:s},force:{x:0,y:0},displacement:{x:0,y:0},isFixed:i,fixedX:i,fixedY:i,mass:1})}addTriangle(t,e,s){const i=this.calculateTriangleArea(e);this.triangles.set(t,{id:t,nodeIds:e,materialProps:s,area:i,strain:[0,0,0],stress:[0,0,0]})}setFixedNode(t,e=!0,s=!0){const i=this.nodes.get(t);i&&(i.fixedX=e,i.fixedY=s,i.isFixed=e||s)}applyForce(t,e,s){const i=this.nodes.get(t);i&&(i.force.x+=e,i.force.y+=s)}getNodes(){return Array.from(this.nodes.values())}getNode(t){return this.nodes.get(t)}getTriangles(){return Array.from(this.triangles.values())}getTriangle(t){return this.triangles.get(t)}calculateMCSS(t){const e=new Map,s=Math.tan(t*Math.PI/180);for(const t of this.triangles.values()){const[i,o,n]=t.stress,r=(i+o)/2,a=Math.sqrt(Math.pow((i-o)/2,2)+n*n),c=r+a,d=r-a,l=(c-d)/2*Math.sqrt(1+s*s)-s*(c+d)/2;e.set(t.id,l)}return e}exportResults(){return{nodes:this.getNodes().map(t=>({id:t.id,x:t.position.x,y:t.position.y,fx:t.force.x,fy:t.force.y})),triangles:this.getTriangles().map(t=>({id:t.id,nodes:[...t.nodeIds],stress:[...t.stress],strain:[...t.strain]}))}}computeNodalForces(t){const e=this.computeStrain(t),s=this.computeStress(t,e);t.strain=e,t.stress=s;const i=t.area,o=this.getShapeFunctionDerivatives(t),n=[[o[0][0],0,o[1][0],0,o[2][0],0],[0,o[0][1],0,o[1][1],0,o[2][1]],[o[0][1],o[0][0],o[1][1],o[1][0],o[2][1],o[2][0]]],r=Array(6).fill(0);for(let t=0;t<6;t++)for(let e=0;e<3;e++)r[t]+=n[e][t]*s[e]*i*1;const a=new Map,c=t.nodeIds;for(let t=0;t<3;t++)a.set(c[t],{x:r[2*t],y:r[2*t+1]});return a}computeNodalStiffness(t){const e=[[0,0],[0,0]];for(const s of this.triangles.values()){const i=s.nodeIds.indexOf(t);if(-1!==i){const t=this.computeElementStiffness(s),o=2*i;e[0][0]+=t[o][o],e[0][1]+=t[o][o+1],e[1][0]+=t[o+1][o],e[1][1]+=t[o+1][o+1]}}return e}calculateTriangleArea(t){const[e,s,i]=t.map(t=>this.nodes.get(t).position);return.5*Math.abs((s.x-e.x)*(i.y-e.y)-(i.x-e.x)*(s.y-e.y))}computeStrain(t){const[e,s,i]=t.nodeIds,o=[this.nodes.get(e),this.nodes.get(s),this.nodes.get(i)],n=(t.area,this.getShapeFunctionDerivatives(t)),r=[[n[0][0],0,n[1][0],0,n[2][0],0],[0,n[0][1],0,n[1][1],0,n[2][1]],[n[0][1],n[0][0],n[1][1],n[1][0],n[2][1],n[2][0]]],a=[o[0].displacement.x,o[0].displacement.y,o[1].displacement.x,o[1].displacement.y,o[2].displacement.x,o[2].displacement.y],c=[0,0,0];for(let t=0;t<3;t++)for(let e=0;e<6;e++)c[t]+=r[t][e]*a[e];return c}getShapeFunctionDerivatives(t){const[e,s,i]=t.nodeIds,[o,n,r]=[this.nodes.get(e).position,this.nodes.get(s).position,this.nodes.get(i).position],a=2*t.area;return[[(n.y-r.y)/a,(r.x-n.x)/a],[(r.y-o.y)/a,(o.x-r.x)/a],[(o.y-n.y)/a,(n.x-o.x)/a]]}computeStress(t,e){const{youngModulus:s,poissonRatio:i}=t.materialProps,o=s/(1-i*i),n=[[o,o*i,0],[o*i,o,0],[0,0,o*(1-i)/2]],r=[0,0,0];for(let t=0;t<3;t++)for(let s=0;s<3;s++)r[t]+=n[t][s]*e[s];return r}computeElementStiffness(t){const{youngModulus:e,poissonRatio:s}=t.materialProps,i=t.area,o=this.getShapeFunctionDerivatives(t),n=e/(1-s*s),r=[[n,n*s,0],[n*s,n,0],[0,0,n*(1-s)/2]],a=[[o[0][0],0,o[1][0],0,o[2][0],0],[0,o[0][1],0,o[1][1],0,o[2][1]],[o[0][1],o[0][0],o[1][1],o[1][0],o[2][1],o[2][0]]],c=Array(6).fill(0).map(()=>Array(6).fill(0));for(let t=0;t<6;t++)for(let e=0;e<6;e++)for(let s=0;s<3;s++)for(let o=0;o<3;o++)c[t][e]+=a[s][t]*r[s][o]*a[o][e]*i*1;return c}detectContacts(){this.contacts=[]}applyContactForces(){for(const t of this.contacts){const e=this.nodes.get(t.slaveNodeId);if(e&&t.distance<0){const s=1e6*Math.abs(t.distance);e.force.x+=s*t.normal.x,e.force.y+=s*t.normal.y}}}}function o(t,e,s,i){console.log("Starting geological restoration...");for(const e of s){const s=t.getNode(e);s&&(s.position.y=i,s.fixedY=!0,s.fixedX=!1)}e.start(t),console.log("Geological restoration completed")}return e})());