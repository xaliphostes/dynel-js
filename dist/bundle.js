!function(t,s){"object"==typeof exports&&"object"==typeof module?module.exports=s():"function"==typeof define&&define.amd?define([],s):"object"==typeof exports?exports.dynel=s():t.dynel=s()}(this,()=>(()=>{"use strict";var t={d:(s,e)=>{for(var i in e)t.o(e,i)&&!t.o(s,i)&&Object.defineProperty(s,i,{enumerable:!0,get:e[i]})},o:(t,s)=>Object.prototype.hasOwnProperty.call(t,s),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},s={};t.r(s),t.d(s,{GNode:()=>e,GaussSeidel:()=>n,Model:()=>o,Triangle:()=>i,restore:()=>r});class e{constructor(t,s,e=!1){this.id=-1,this.position={x:0,y:0},this.originalPosition={x:0,y:0},this.force={x:0,y:0},this.displacement={x:0,y:0},this.isFixed=!1,this.fixedX=!1,this.fixedY=!1,this.mass=0,this.triangles_=[],this.id=t,this.position=s,this.originalPosition=s,this.isFixed=e}addTriangle(t){this.triangles_.push(t)}get triangles(){return this.triangles_}stiffness(){const t=[[0,0],[0,0]];return this.triangles.forEach(s=>{const e=s.stiffness(),i=2*this.id;t[0][0]+=e[i][i],t[0][1]+=e[i][i+1],t[1][0]+=e[i+1][i],t[1][1]+=e[i+1][i+1]}),t}nodalForce(){let t={x:this.force.x,y:this.force.y};return this.triangles.forEach(s=>{const e=s.nodalForces().get(this.id);t.x+=e.x,t.y+=e.y}),t}nodalDisplacement(){if(this.isFixed)return;const t=this.nodalForce(),s=this.stiffness(),e=s[0][0]*s[1][1]-s[0][1]*s[1][0];if(Math.abs(e)>1e-12){const i=[[s[1][1]/e,-s[0][1]/e],[-s[1][0]/e,s[0][0]/e]];return{x:i[0][0]*t.x+i[0][1]*t.y,y:i[1][0]*t.x+i[1][1]*t.y}}}}class i{constructor(t,s,e,i,n){this.id=-1,this.materialProps={youngModulus:1,poissonRatio:.3,density:1},this.area=0,this.strain=[0,0,0],this.stress=[0,0,0],this.shapeFunctionDerivatives=[[0,0],[0,0],[0,0]],this.id=t,this.nodes=[s,e,i],this.materialProps=n,this.area=this.calculateArea(),this.strain=[0,0,0],this.stress=[0,0,0],this.shapeFunctionDerivatives=this.computeShapeFunctionDerivatives()}nodeIds(){return this.nodes.map(t=>t.id)}nodalForces(){const t=this.computeStrain(),s=this.computeStress(t),e=this.area,i=this.shapeFunctionDerivatives,n=[[i[0][0],0,i[1][0],0,i[2][0],0],[0,i[0][1],0,i[1][1],0,i[2][1]],[i[0][1],i[0][0],i[1][1],i[1][0],i[2][1],i[2][0]]],o=Array(6).fill(0);for(let t=0;t<6;t++)for(let i=0;i<3;i++)o[t]+=n[i][t]*s[i]*e*1;const r=new Map;return this.nodes.map((t,s)=>{r.set(t.id,{x:o[2*s],y:o[2*s+1]})}),r}stiffness(){const{youngModulus:t,poissonRatio:s}=this.materialProps,e=this.area,i=this.shapeFunctionDerivatives,n=t/(1-s*s),o=[[n,n*s,0],[n*s,n,0],[0,0,n*(1-s)/2]],r=[[i[0][0],0,i[1][0],0,i[2][0],0],[0,i[0][1],0,i[1][1],0,i[2][1]],[i[0][1],i[0][0],i[1][1],i[1][0],i[2][1],i[2][0]]],a=Array(6).fill(0).map(()=>Array(6).fill(0));for(let t=0;t<6;t++)for(let s=0;s<6;s++)for(let i=0;i<3;i++)for(let n=0;n<3;n++)a[t][s]+=r[i][t]*o[i][n]*r[n][s]*e*1;return a}calculateArea(){const[t,s,e]=this.nodes.map(t=>t.position);return.5*Math.abs((s.x-t.x)*(e.y-t.y)-(e.x-t.x)*(s.y-t.y))}computeStrain(){const[t,s,e]=this.nodes.map(t=>t.id),i=this.nodes,n=(this.area,this.shapeFunctionDerivatives),o=[[n[0][0],0,n[1][0],0,n[2][0],0],[0,n[0][1],0,n[1][1],0,n[2][1]],[n[0][1],n[0][0],n[1][1],n[1][0],n[2][1],n[2][0]]],r=[i[0].displacement.x,i[0].displacement.y,i[1].displacement.x,i[1].displacement.y,i[2].displacement.x,i[2].displacement.y],a=[0,0,0];for(let t=0;t<3;t++)for(let s=0;s<6;s++)a[t]+=o[t][s]*r[s];return a}computeStress(t){const{youngModulus:s,poissonRatio:e}=this.materialProps,i=s/(1-e*e),n=[[i,i*e,0],[i*e,i,0],[0,0,i*(1-e)/2]],o=[0,0,0];for(let s=0;s<3;s++)for(let e=0;e<3;e++)o[s]+=n[s][e]*t[e];return o}computeShapeFunctionDerivatives(){const[t,s,e]=this.nodes.map(t=>t.id),[i,n,o]=[this.nodes[0].position,this.nodes[1].position,this.nodes[2].position],r=2*this.area;return[[(n.y-o.y)/r,(o.x-n.x)/r],[(o.y-i.y)/r,(i.x-o.x)/r],[(i.y-n.y)/r,(n.x-i.x)/r]]}}class n{constructor(t=1e-6,s=1e4,e=.8){this.convergenceThreshold=1e-7,this.maxIterations=5e4,this.damping=.8,this.isRunning=!1,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0,this.convergenceThreshold=t,this.maxIterations=s,this.damping=e}get running(){return this.isRunning}get paused(){return this.isPaused}get iterations(){return this.currentIteration}get error(){return this.currentError}setConvergenceThreshold(t){this.convergenceThreshold=t}setMaxIterations(t){this.maxIterations=t}setDamping(t){this.damping=t}start(t){this.isRunning=!0,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0;for(const s of t.getNodes())s.displacement={x:0,y:0}}async step(t){if(!this.isRunning||this.isPaused)return null;const s=this.iteration(t);this.currentIteration++,this.currentError=s;const e=s<=this.convergenceThreshold,i=this.currentIteration>=this.maxIterations;return(e||i)&&(this.isRunning=!1),{converged:e,iterations:this.currentIteration,error:s,running:this.isRunning,maxDisplacement:s}}pause(){this.isPaused=!this.isPaused}reset(t){this.isRunning=!1,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0;for(const s of t.getNodes())s.position.x=s.originalPosition.x,s.position.y=s.originalPosition.y,s.displacement={x:0,y:0},s.force={x:0,y:0}}async solve(t,s,e,i=1){if(this.isRunning)return;this.start(t);const n=16/i;for(;this.isRunning;){const i=await this.step(t);if(i){if(s(),e(i),i.converged){console.log(`Solver converged after ${i.iterations} iterations with error ${i.error.toExponential(3)}`);break}if(i.iterations>=this.maxIterations){console.log(`Solver stopped at max iterations (${i.iterations}) with error ${i.error.toExponential(3)}`);break}}await new Promise(t=>setTimeout(t,n))}this.isRunning=!1}iteration(t){let s=0;for(const e of t.getNodes()){const t=e.nodalDisplacement();t&&(e.fixedX||(e.position.x+=this.damping*t.x,e.displacement.x+=this.damping*t.x,s=Math.max(s,Math.abs(t.x))),e.fixedY||(e.position.y+=this.damping*t.y,e.displacement.y+=this.damping*t.y,s=Math.max(s,Math.abs(t.y))))}return s}}class o{constructor(){this.nodes=new Map,this.triangles=new Map,this.contacts=[]}addNode(t,s,i,n=!1){this.nodes.set(t,new e(t,{x:s,y:i},n))}addTriangle(t,s,e){const n=this.nodes.get(s[0]),o=this.nodes.get(s[1]),r=this.nodes.get(s[2]);if(!n||!o||!r)throw new Error(`Nodes with IDs ${s.join(", ")} not found`);this.triangles.set(t,new i(t,n,o,r,e))}setFixedNode(t,s=!0,e=!0){const i=this.nodes.get(t);i&&(i.fixedX=s,i.fixedY=e,i.isFixed=s||e)}applyForce(t,s,e){const i=this.nodes.get(t);i&&(i.force.x+=s,i.force.y+=e)}getNodes(){return Array.from(this.nodes.values())}getNode(t){return this.nodes.get(t)}getTriangles(){return Array.from(this.triangles.values())}getTriangle(t){return this.triangles.get(t)}calculateMCSS(t){const s=new Map,e=Math.tan(t*Math.PI/180);for(const t of this.triangles.values()){const[i,n,o]=t.stress,r=(i+n)/2,a=Math.sqrt(Math.pow((i-n)/2,2)+o*o),h=r+a,c=r-a,d=(h-c)/2*Math.sqrt(1+e*e)-e*(h+c)/2;s.set(t.id,d)}return s}exportResults(){return{nodes:this.getNodes().map(t=>({id:t.id,x:t.position.x,y:t.position.y,fx:t.force.x,fy:t.force.y})),triangles:this.getTriangles().map(t=>({id:t.id,nodes:[...t.nodes.map(t=>t.id)],stress:[...t.stress],strain:[...t.strain]}))}}detectContacts(){this.contacts=[]}applyContactForces(){for(const t of this.contacts){const s=this.nodes.get(t.slaveNodeId);if(s&&t.distance<0){const e=1e6*Math.abs(t.distance);s.force.x+=e*t.normal.x,s.force.y+=e*t.normal.y}}}}function r(t,s,e,i){console.log("Starting geological restoration...");for(const s of e){const e=t.getNode(s);e&&(e.position.y=i,e.fixedY=!0,e.fixedX=!1)}s.start(t),console.log("Geological restoration completed")}return s})());