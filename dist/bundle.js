!function(t,i){"object"==typeof exports&&"object"==typeof module?module.exports=i():"function"==typeof define&&define.amd?define([],i):"object"==typeof exports?exports.dynel=i():t.dynel=i()}(this,()=>(()=>{"use strict";var t={d:(i,s)=>{for(var e in s)t.o(s,e)&&!t.o(i,e)&&Object.defineProperty(i,e,{enumerable:!0,get:s[e]})},o:(t,i)=>Object.prototype.hasOwnProperty.call(t,i),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},i={};function s(t){return 0===t.x&&0===t.y}t.r(i),t.d(i,{GNode:()=>e,GaussSeidel:()=>r,Material:()=>n,Model:()=>a,Triangle:()=>o,isNull:()=>s,restore:()=>h});class e{constructor(t,i,s=!1){this.id=-1,this.position={x:0,y:0},this.originalPosition={x:0,y:0},this.force={x:0,y:0},this.displacement={x:0,y:0},this.isFixed=!1,this.fixedX=!1,this.fixedY=!1,this.mass=1,this.triangles_=[],this.K_=[],this.iK_=[],this.isSingular=!1,this.id=t,this.position=i,this.originalPosition=i,this.isFixed=s}addTriangle(t){this.triangles_.push(t)}get triangles(){return this.triangles_}initialize(){this.K_=this.computeStiffness();const t=this.K_,i=t[0][0]*t[1][1]-t[0][1]*t[1][0];Math.abs(i)>1e-12?(this.iK_=[[t[1][1]/i,-t[0][1]/i],[-t[1][0]/i,t[0][0]/i]],this.isSingular=!1):this.isSingular=!0}nodalForce(){let t={x:this.force.x,y:this.force.y};return this.triangles.forEach(i=>{const s=i.nodalForces().get(this.id);t.x+=s.x,t.y+=s.y}),t}nodalDisplacement(){if(this.isFixed||this.isSingular)return;const t=this.nodalForce();return s(t)?void 0:{x:this.iK_[0][0]*t.x+this.iK_[0][1]*t.y,y:this.iK_[1][0]*t.x+this.iK_[1][1]*t.y}}extractIdFromTriangle(t){return t.node(0)===this?0:t.node(1)===this?1:2}computeStiffness(){const t=[[0,0],[0,0]];return this.triangles.forEach(i=>{const s=i.stiffness,e=2*this.extractIdFromTriangle(i);t[0][0]+=s[e][e],t[0][1]+=s[e][e+1],t[1][0]+=s[e+1][e],t[1][1]+=s[e+1][e+1]}),t}}class n{constructor(t,i,s){this.youngModulus_=1,this.poissonRatio_=.25,this.density_=1,this.D_=[],this.youngModulus_=t,this.poissonRatio_=i,this.density_=s,this.initialize()}get youngModulus(){return this.youngModulus_}set youngModulus(t){this.youngModulus_=t,this.initialize()}get poissonRatio(){return this.poissonRatio_}set poissonRatio(t){this.poissonRatio_=t,this.initialize()}get density(){return this.density_}set density(t){this.density_=t}get D(){return this.D_}initialize(){const t=this.youngModulus_,i=this.poissonRatio_,s=t/(1-i*i);this.D_=[[s,s*i,0],[s*i,s,0],[0,0,s*(1-i)/2]]}}class o{constructor(t,i,s,e,o){this.id=-1,this.material=new n(1,.3,1),this.area=0,this.shapeFunctionDerivatives=[[0,0],[0,0],[0,0]],this.B=[],this.K=[],this.id=t,this.nodes=[i,s,e],this.material=o,this.area=this.computeArea(),this.shapeFunctionDerivatives=this.computeShapeFunctionDerivatives(),i.addTriangle(this),s.addTriangle(this),e.addTriangle(this)}initialize(){this.area=this.computeArea(),this.shapeFunctionDerivatives=this.computeShapeFunctionDerivatives();const t=this.shapeFunctionDerivatives;this.B=[[t[0][0],0,t[1][0],0,t[2][0],0],[0,t[0][1],0,t[1][1],0,t[2][1]],[t[0][1],t[0][0],t[1][1],t[1][0],t[2][1],t[2][0]]],this.K=this.computeStiffness()}get stiffness(){return this.K}nodeIds(){return this.nodes.map(t=>t.id)}node(t){return this.nodes[t]}nodalForces(){const t=this.computeStress(this.computeStrain()),i=this.area,s=Array(6).fill(0);for(let e=0;e<6;e++)for(let n=0;n<3;n++)s[e]+=this.B[n][e]*t[n]*i*1;const e=new Map;return this.nodes.map((t,i)=>{e.set(t.id,{x:s[2*i],y:s[2*i+1]})}),e}get strain(){return this.computeStrain()}get stress(){return this.computeStress(this.computeStrain())}computeStiffness(){const t=this.material.youngModulus,i=this.material.poissonRatio,s=this.area,e=(this.shapeFunctionDerivatives,t/(1-i*i)),n=[[e,e*i,0],[e*i,e,0],[0,0,e*(1-i)/2]],o=Array(6).fill(0).map(()=>Array(6).fill(0));for(let t=0;t<6;t++)for(let i=0;i<6;i++)for(let e=0;e<3;e++)for(let r=0;r<3;r++)o[t][i]+=this.B[e][t]*n[e][r]*this.B[r][i]*s*1;return o}computeArea(){const[t,i,s]=this.nodes.map(t=>t.position);return.5*Math.abs((i.x-t.x)*(s.y-t.y)-(s.x-t.x)*(i.y-t.y))}computeStrain(){const t=this.nodes,i=[t[0].displacement.x,t[0].displacement.y,t[1].displacement.x,t[1].displacement.y,t[2].displacement.x,t[2].displacement.y],s=[0,0,0];for(let t=0;t<3;t++)for(let e=0;e<6;e++)s[t]+=this.B[t][e]*i[e];return s}computeStress(t){const i=this.material.D,s=[0,0,0];for(let e=0;e<3;e++)for(let n=0;n<3;n++)s[e]+=i[e][n]*t[n];return s}computeShapeFunctionDerivatives(){const[t,i,s]=[this.nodes[0].position,this.nodes[1].position,this.nodes[2].position],e=2*this.area;return[[(i.y-s.y)/e,(s.x-i.x)/e],[(s.y-t.y)/e,(t.x-s.x)/e],[(t.y-i.y)/e,(i.x-t.x)/e]]}}class r{constructor(t=1e-6,i=1e4,s=.8){this.convergenceThreshold=1e-7,this.maxIterations=5e4,this.damping=.8,this.isRunning=!1,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0,this.convergenceThreshold=t,this.maxIterations=i,this.damping=s}get running(){return this.isRunning}get paused(){return this.isPaused}get iterations(){return this.currentIteration}get error(){return this.currentError}setConvergenceThreshold(t){this.convergenceThreshold=t}setMaxIterations(t){this.maxIterations=t}setDamping(t){this.damping=t}start(t){this.isRunning=!0,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0;for(const i of t.getNodes())i.displacement={x:0,y:0}}async step(t){if(!this.isRunning||this.isPaused)return null;const i=this.iteration(t);this.currentIteration++,this.currentError=i;const s=i<=this.convergenceThreshold,e=this.currentIteration>=this.maxIterations;return(s||e)&&(this.isRunning=!1),{converged:s,iterations:this.currentIteration,error:i,running:this.isRunning,maxDisplacement:i}}pause(){this.isPaused=!this.isPaused}reset(t){this.isRunning=!1,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0;for(const i of t.getNodes())i.position.x=i.originalPosition.x,i.position.y=i.originalPosition.y,i.displacement={x:0,y:0},i.force={x:0,y:0}}async solve(t,i,s,e=1){if(this.isRunning)return;this.start(t);const n=16/e;for(;this.isRunning;){const e=await this.step(t);if(e){if(i(),s(e),e.converged){console.log(`Solver converged after ${e.iterations} iterations with error ${e.error.toExponential(3)}`);break}if(e.iterations>=this.maxIterations){console.log(`Solver stopped at max iterations (${e.iterations}) with error ${e.error.toExponential(3)}`);break}}await new Promise(t=>setTimeout(t,n))}this.isRunning=!1}iteration(t){let i=0;for(const s of t.getNodes()){const t=s.nodalDisplacement();t&&(s.fixedX||(s.position.x+=this.damping*t.x,s.displacement.x+=this.damping*t.x,i=Math.max(i,Math.abs(t.x))),s.fixedY||(s.position.y+=this.damping*t.y,s.displacement.y+=this.damping*t.y,i=Math.max(i,Math.abs(t.y))))}return i}}class a{constructor(){this.beginC_=!1,this.isNode_=!1,this.isTriangle_=!1,this.nodes=new Map,this.triangles=new Map,this.contacts=[]}beginConstruction(){if(this.beginC_)throw"Already in construction mode";this.beginC_=!0,this.isNode_=!1,this.isTriangle_=!1}beginNodes(){if(!this.beginC_)throw"You must call beginConstruction first";this.isNode_=!0}addNode(t,i,s,n=!1){if(!this.beginC_)throw"You must call beginConstruction before adding nodes";if(!this.isNode_)throw"you must call beginNodes first";this.nodes.set(t,new e(t,{x:i,y:s},n))}endNodes(){if(!this.isNode_)throw"You must call beginNode first and add the nodes";this.isNode_=!1}beginTriangles(){if(this.isNode_)throw"You must call endNodes";this.isTriangle_=!0}addTriangle(t,i,s){if(!this.isTriangle_)throw"You must call beginTraingles before adding triangles";const e=this.nodes.get(i[0]),n=this.nodes.get(i[1]),r=this.nodes.get(i[2]);if(!e||!n||!r)throw new Error(`Nodes with IDs ${i.join(", ")} not found`);this.triangles.set(t,new o(t,e,n,r,s))}endTriangles(){if(!this.isTriangle_)throw"You must call beginTriangles first and add the triangles";this.isTriangle_=!1}endConstruction(){if(!this.beginC_)throw"You must begin a construction before calling endConstruction";if(this.isTriangle_)throw"You must call endTriangles";this.beginC_=!1,this.isNode_=!1,this.isTriangle_=!1,this.triangles.forEach(t=>t.initialize()),this.nodes.forEach(t=>t.initialize())}setFixedNode(t,i=!0,s=!0){const e=this.nodes.get(t);e&&(e.fixedX=i,e.fixedY=s,e.isFixed=i||s)}applyForce(t,i,s){const e=this.nodes.get(t);e&&(e.force.x+=i,e.force.y+=s)}getNodes(){return Array.from(this.nodes.values())}getNode(t){return this.nodes.get(t)}getTriangles(){return Array.from(this.triangles.values())}getTriangle(t){return this.triangles.get(t)}calculateMCSS(t){const i=new Map,s=Math.tan(t*Math.PI/180);for(const t of this.triangles.values()){const[e,n,o]=t.stress,r=(e+n)/2,a=Math.sqrt(Math.pow((e-n)/2,2)+o*o),h=r+a,d=r-a,c=(h-d)/2*Math.sqrt(1+s*s)-s*(h+d)/2;i.set(t.id,c)}return i}exportResults(){return{nodes:this.getNodes().map(t=>({id:t.id,x:t.position.x,y:t.position.y,fx:t.force.x,fy:t.force.y})),triangles:this.getTriangles().map(t=>({id:t.id,nodes:[...t.nodes.map(t=>t.id)],stress:[...t.stress],strain:[...t.strain]}))}}detectContacts(){this.contacts=[]}applyContactForces(){for(const t of this.contacts){const i=this.nodes.get(t.slaveNodeId);if(i&&t.distance<0){const s=1e6*Math.abs(t.distance);i.force.x+=s*t.normal.x,i.force.y+=s*t.normal.y}}}}function h(t,i,s,e){console.log("Starting geological restoration...");for(const i of s){const s=t.getNode(i);s&&(s.position.y=e,s.fixedY=!0,s.fixedX=!1)}i.start(t),console.log("Geological restoration completed")}return i})());