!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.dynel=e():t.dynel=e()}(this,()=>(()=>{"use strict";var t={d:(e,s)=>{for(var o in s)t.o(s,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:s[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{GeomechanicalRestoration:()=>s});class s{constructor(t=1e-6,e=1e4){this.nodes=new Map,this.triangles=new Map,this.contacts=[],this.convergenceThreshold=1e-6,this.maxIterations=1e4,this.damping=.8,this.isRunning=!1,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0,this.convergenceThreshold=t,this.maxIterations=e}addNode(t,e,s,o=!1){this.nodes.set(t,{id:t,position:{x:e,y:s},originalPosition:{x:e,y:s},force:{x:0,y:0},displacement:{x:0,y:0},isFixed:o,fixedX:o,fixedY:o,mass:1})}addTriangle(t,e,s){const o=this.calculateTriangleArea(e);this.triangles.set(t,{id:t,nodeIds:e,materialProps:s,area:o,strain:[0,0,0],stress:[0,0,0]})}setFixedNode(t,e=!0,s=!0){const o=this.nodes.get(t);o&&(o.fixedX=e,o.fixedY=s,o.isFixed=e||s)}applyForce(t,e,s){const o=this.nodes.get(t);o&&(o.force.x+=e,o.force.y+=s)}calculateTriangleArea(t){const[e,s,o]=t.map(t=>this.nodes.get(t).position);return.5*Math.abs((s.x-e.x)*(o.y-e.y)-(o.x-e.x)*(s.y-e.y))}computeStrain(t){const[e,s,o]=t.nodeIds,i=[this.nodes.get(e),this.nodes.get(s),this.nodes.get(o)],n=(t.area,this.getShapeFunctionDerivatives(t)),r=[[n[0][0],0,n[1][0],0,n[2][0],0],[0,n[0][1],0,n[1][1],0,n[2][1]],[n[0][1],n[0][0],n[1][1],n[1][0],n[2][1],n[2][0]]],a=[i[0].displacement.x,i[0].displacement.y,i[1].displacement.x,i[1].displacement.y,i[2].displacement.x,i[2].displacement.y],c=[0,0,0];for(let t=0;t<3;t++)for(let e=0;e<6;e++)c[t]+=r[t][e]*a[e];return c}getShapeFunctionDerivatives(t){const[e,s,o]=t.nodeIds,[i,n,r]=[this.nodes.get(e).position,this.nodes.get(s).position,this.nodes.get(o).position],a=2*t.area;return[[(n.y-r.y)/a,(r.x-n.x)/a],[(r.y-i.y)/a,(i.x-r.x)/a],[(i.y-n.y)/a,(n.x-i.x)/a]]}computeStress(t,e){const{youngModulus:s,poissonRatio:o}=t.materialProps,i=s/(1-o*o),n=[[i,i*o,0],[i*o,i,0],[0,0,i*(1-o)/2]],r=[0,0,0];for(let t=0;t<3;t++)for(let s=0;s<3;s++)r[t]+=n[t][s]*e[s];return r}computeElementStiffness(t){const{youngModulus:e,poissonRatio:s}=t.materialProps,o=t.area,i=this.getShapeFunctionDerivatives(t),n=e/(1-s*s),r=[[n,n*s,0],[n*s,n,0],[0,0,n*(1-s)/2]],a=[[i[0][0],0,i[1][0],0,i[2][0],0],[0,i[0][1],0,i[1][1],0,i[2][1]],[i[0][1],i[0][0],i[1][1],i[1][0],i[2][1],i[2][0]]],c=Array(6).fill(0).map(()=>Array(6).fill(0));for(let t=0;t<6;t++)for(let e=0;e<6;e++)for(let s=0;s<3;s++)for(let i=0;i<3;i++)c[t][e]+=a[s][t]*r[s][i]*a[i][e]*o*1;return c}computeNodalForces(t){const e=this.computeStrain(t),s=this.computeStress(t,e);t.strain=e,t.stress=s;const o=t.area,i=this.getShapeFunctionDerivatives(t),n=[[i[0][0],0,i[1][0],0,i[2][0],0],[0,i[0][1],0,i[1][1],0,i[2][1]],[i[0][1],i[0][0],i[1][1],i[1][0],i[2][1],i[2][0]]],r=Array(6).fill(0);for(let t=0;t<6;t++)for(let e=0;e<3;e++)r[t]+=n[e][t]*s[e]*o*1;const a=new Map,c=t.nodeIds;for(let t=0;t<3;t++)a.set(c[t],{x:r[2*t],y:r[2*t+1]});return a}detectContacts(){this.contacts=[]}applyContactForces(){for(const t of this.contacts){const e=this.nodes.get(t.slaveNodeId);if(e&&t.distance<0){const s=1e6*Math.abs(t.distance);e.force.x+=s*t.normal.x,e.force.y+=s*t.normal.y}}}computeNodalStiffness(t){const e=[[0,0],[0,0]];for(const s of this.triangles.values()){const o=s.nodeIds.indexOf(t);if(-1!==o){const t=this.computeElementStiffness(s),i=2*o;e[0][0]+=t[i][i],e[0][1]+=t[i][i+1],e[1][0]+=t[i+1][i],e[1][1]+=t[i+1][i+1]}}return e}restoreGeology(t,e){console.log("Starting geological restoration...");for(const s of t){const t=this.nodes.get(s);t&&(t.position.y=e,t.fixedY=!0,t.fixedX=!1)}this.startSolver(),console.log("Geological restoration completed")}getNodes(){return Array.from(this.nodes.values())}getTriangles(){return Array.from(this.triangles.values())}async solve(t,e,s=1){if(this.isRunning)return;this.isRunning=!0;const o=16/s;for(;this.isRunning;){const s=await this.solveStep();if(t(),e(s),s&&s.converged){console.log(`Solver converged after ${s.iterations} iterations with error ${s.error.toExponential(3)}`);break}if(s&&s.iterations>=this.maxIterations){console.log(`Solver stopped at max iterations (${s.iterations}) with error ${s.error.toExponential(3)}`);break}await new Promise(t=>setTimeout(t,o))}this.isRunning=!1}async solveStep(){if(!this.isRunning||this.isPaused)return null;const t=this.gaussSeidelIteration();this.currentIteration++,this.currentError=t;const e=t<=this.convergenceThreshold,s=this.currentIteration>=this.maxIterations;return(e||s)&&(this.isRunning=!1),{converged:e,iterations:this.currentIteration,error:t,running:this.isRunning,maxDisplacement:t}}gaussSeidelIteration(){let t=0;for(const e of this.nodes.values()){if(e.isFixed)continue;let s={x:e.force.x,y:e.force.y};for(const t of this.triangles.values())if(t.nodeIds.includes(e.id)){const o=this.computeNodalForces(t).get(e.id);o&&(s.x+=o.x,s.y+=o.y)}const o=this.computeNodalStiffness(e.id),i=o[0][0]*o[1][1]-o[0][1]*o[1][0];if(Math.abs(i)>1e-12){const n=[[o[1][1]/i,-o[0][1]/i],[-o[1][0]/i,o[0][0]/i]],r={x:n[0][0]*s.x+n[0][1]*s.y,y:n[1][0]*s.x+n[1][1]*s.y};e.fixedX||(e.position.x+=this.damping*r.x,e.displacement.x+=this.damping*r.x,t=Math.max(t,Math.abs(r.x))),e.fixedY||(e.position.y+=this.damping*r.y,e.displacement.y+=this.damping*r.y,t=Math.max(t,Math.abs(r.y)))}}return t}startSolver(){this.isRunning=!0,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0;for(const t of this.nodes.values())t.displacement={x:0,y:0}}pauseSolver(){this.isPaused=!this.isPaused}resetSolver(){this.isRunning=!1,this.isPaused=!1,this.currentIteration=0,this.currentError=1/0;for(const t of this.nodes.values())t.position.x=t.originalPosition.x,t.position.y=t.originalPosition.y,t.displacement={x:0,y:0},t.force={x:0,y:0}}calculateMCSS(t){const e=new Map,s=Math.tan(t*Math.PI/180);for(const t of this.triangles.values()){const[o,i,n]=t.stress,r=(o+i)/2,a=Math.sqrt(Math.pow((o-i)/2,2)+n*n),c=r+a,l=r-a,d=(c-l)/2*Math.sqrt(1+s*s)-s*(c+l)/2;e.set(t.id,d)}return e}exportResults(){return{nodes:this.getNodes().map(t=>({id:t.id,x:t.position.x,y:t.position.y,fx:t.force.x,fy:t.force.y})),triangles:this.getTriangles().map(t=>({id:t.id,nodes:[...t.nodeIds],stress:[...t.stress],strain:[...t.strain]}))}}}return e})());